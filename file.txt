package main

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"

	"github.com/pion/interceptor"
	"github.com/pion/webrtc/v4"
)

func main() {

	fmt.Println("hello world");

	mediaEngine := &webrtc.MediaEngine{}

	if err := mediaEngine.RegisterDefaultCodecs(); err != nil {
		panic(err)
	}

	i := &interceptor.Registry{}


	if err := webrtc.RegisterDefaultInterceptors(mediaEngine, i); err != nil {
		panic(err)
	}

	api := webrtc.NewAPI(webrtc.WithMediaEngine(mediaEngine), webrtc.WithInterceptorRegistry(i))

	peerConnection, err := api.NewPeerConnection(webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{},
			},
		},
	});

	if err != nil {
		panic(err)
	}

	defer func()  {
		if closeError := peerConnection.Close(); closeError != nil {
			fmt.Printf("cannot close peerConnection: %v\n",closeError);
		}
	}()

	if _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeAudio); err != nil {
		panic(err)
	}

	peerConnection.OnTrack(func(track *webrtc.TrackRemote, r *webrtc.RTPReceiver) {
		// handle audio track, save to disk
		codec := track.Codec()
		fmt.Println(codec);
	});

	peerConnection.OnConnectionStateChange(func(pcs webrtc.PeerConnectionState) {
		fmt.Println("Peer Connection changed",pcs.String());

		if pcs == webrtc.PeerConnectionStateFailed {
			fmt.Println("Peer Connection has gone to failed exiting")
			os.Exit(0)
		}
	})

	offer := webrtc.SessionDescription{}
	var name string
	fmt.Scanln(&name);

	str := readFileContent()
	decode(str, &offer);

	// Set the remote SessionDescription
	err = peerConnection.SetRemoteDescription(offer)
	if err != nil {
		panic(err)
	}

	// Create answer
	answer, err := peerConnection.CreateAnswer(nil)
	if err != nil {
		panic(err)
	}

	// Create channel that is blocked until ICE Gathering is complete
	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	// Sets the LocalDescription, and starts our UDP listeners
	err = peerConnection.SetLocalDescription(answer)
	if err != nil {
		panic(err)
	}

	// Block until ICE Gathering is complete, disabling trickle ICE
	// we do this because we only can exchange one signaling message
	// in a production application you should exchange ICE Candidates via OnICECandidate
	<-gatherComplete

	fmt.Println("testing!!!")
	// Output the answer in base64 so we can paste it in browser
	fmt.Println(encode(peerConnection.LocalDescription()))

	// Block forever
	select {}
}

func readFileContent() string  {
	b, err := os.ReadFile("file.txt") // just pass the file name
    if err != nil {
        fmt.Print(err)
    }

    str := string(b) // convert content to a 'string'

	return str
}

// Decode a base64 and unmarshal JSON into a SessionDescription
func decode(in string, obj *webrtc.SessionDescription) {
	b, err := base64.StdEncoding.DecodeString(in)
	if err != nil {
		panic(err)
	}

	if err = json.Unmarshal(b, obj); err != nil {
		panic(err)
	}
}

// JSON encode + base64 a SessionDescription
func encode(obj *webrtc.SessionDescription) string {
	b, err := json.Marshal(obj)
	if err != nil {
		panic(err)
	}

	return base64.StdEncoding.EncodeToString(b)
}







const pc = new RTCPeerConnection({
        iceServers: [

        ]
    })


    pc.oniceconnectionstatechange = e => console.log(pc.iceConnectionState)

    pc.onconnectionstatechange = (e) => {
        console.log("connection state change ", e);
    }

    pc.onsignalingstatechange = () => {
        console.log("Signaling state changed to:", pc.signalingState);
        console.log("Local description:", pc.localDescription);
        console.log("Current local description:", pc.currentLocalDescription);
    };

    navigator.mediaDevices.getUserMedia({ video: false, audio: true })
        .then(async (stream) => {
            document.getElementById('video1').srcObject = stream
            stream.getTracks().forEach(track => pc.addTrack(track, stream))


        }).catch((err) => console.log(err))

    pc.onicecandidate = async event => {
        if (event.candidate === null) {
            console.log('setting local');
            await pc.setLocalDescription(event.candidate);
            // document.getElementById('localSessionDescription').value = btoa(JSON.stringify(pc.localDescription))
            setTimeout(() => {
                document.getElementById('local').setAttribute("value", btoa(JSON.stringify(pc.localDescription)));
            }, 100);
        }
    }

    document.getElementById("stream").addEventListener("click", async () => {
        toggleViews('streaming', 'recording')

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
    })

    document.getElementById("record").addEventListener("click", () => {
        toggleViews('recording', 'streaming')
    })


    document.getElementById("remote-sdp").addEventListener("click", async (event) => {
        console.log("testing?!");
        const sd = document.getElementById('remote').value
        if (sd === '') {
            return alert('Session Description must not be empty')
        }
        console.log(JSON.parse(atob(sd)));
        try {
            if (!pc.currentRemoteDescription) {
                if (pc.signalingState === "have-local-offer") {
                    console.log("testing!!!");
                    await pc.setRemoteDescription(JSON.parse(atob(sd)));
                    console.log("Remote description set successfully.");
                } else {
                    console.error("Cannot set remote description, current state:", pc.signalingState);
                }
            }
        } catch (e) {
            alert(e)
        }
    })